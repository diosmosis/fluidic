/*
 * Jira Software Data Center REST API Reference
 *
 * This is the reference document for the REST API and resources provided by Jira Software Data Center. The REST APIs are for developers who want to integrate Jira Data Center with other applications, and for administrators who want to script configuration interactions with Jira Data Center.  Jira Data Center is built upon the Jira platform.  As such there is a natural overlap in functionality between what is provided by Jira Data Center and what is provided by the Jira platform.  If you are after an introductory, high-level view of the Jira REST APIs, then the best place to start is the [Jira REST API home](https://developer.atlassian.com/server/jira/platform/rest-apis/). ## Using the REST API Not familiar with the Jira Data Center REST APIs? Start with our [Guide to exploring the Jira Data Center domain model via the REST APIs](https://developer.atlassian.com/server/jira/platform/tutorials_and_guides/), which will help you get a conceptual understanding of the Jira Data Center REST APIs.  If you want instructions on how to use the REST APIs, check out the [Appendix](#appendix) at the end of this page (after the resources), where you'll find information on the following topics: * [Structure of the REST URIs](#structure) * [Authentication](#authentication) * [Pagination](#pagination) * [Expansion](#expansion) * [Special headers](#special-headers) * [Field input formats](#fieldformats) ### Experimental methods Methods marked as `EXPERIMENTAL` may change without notice. We are looking for your feedback for these methods. To use experimental methods, you must set this header in your requests: `X-ExperimentalApi : true`. This indicates that you are opting into the experimental preview. Once a resource or method moves out of the experimental phase, then this header will no longer be required nor checked. 
 *
 * The version of the OpenAPI document: swagger-merged-template.yaml
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_user_to_application1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddUserToApplication1Error {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeUserPasswordError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_avatar_from_temporary4`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAvatarFromTemporary4Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    Status400(),
    Status401(),
    Status403(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`default_columns`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DefaultColumnsError {
    Status401(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_avatar2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAvatar2Error {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_property6`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteProperty6Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSessionError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_assignable_users1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindAssignableUsers1Error {
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_bulk_assignable_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindBulkAssignableUsersError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindUsersError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_users_for_picker`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindUsersForPickerError {
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_users_with_all_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindUsersWithAllPermissionsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_users_with_browse_permission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindUsersWithBrowsePermissionError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_a11y_personal_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetA11yPersonalSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_avatars1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllAvatars1Error {
    Status401(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_duplicated_users_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDuplicatedUsersCountError {
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_duplicated_users_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDuplicatedUsersMappingError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_progress1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProgress1Error {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_properties_keys4`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPropertiesKeys4Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_property6`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProperty6Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUser1Error {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveUserError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_user_from_application1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveUserFromApplication1Error {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_columns`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetColumnsError {
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`schedule_user_anonymization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScheduleUserAnonymizationError {
    Status400(),
    Status403(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`schedule_user_anonymization_rerun`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScheduleUserAnonymizationRerunError {
    Status400(),
    Status403(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_columns_url_encoded`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetColumnsUrlEncodedError {
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_property5`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetProperty5Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_temporary_avatar_using_multi_part3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreTemporaryAvatarUsingMultiPart3Error {
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlock_anonymization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlockAnonymizationError {
    Status400(),
    Status403(),
    Status404(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUser1Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_avatar1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserAvatar1Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_user_anonymization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateUserAnonymizationError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_user_anonymization_rerun`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateUserAnonymizationRerunError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}


/// Add user to given application. Admin permission will be required to perform this operation.
pub async fn add_user_to_application1(configuration: &configuration::Configuration, application_key: Option<&str>, username: Option<&str>) -> Result<(), Error<AddUserToApplication1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_application_key = application_key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/application", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_application_key {
        req_builder = req_builder.query(&[("applicationKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddUserToApplication1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modify user password.
pub async fn change_user_password(configuration: &configuration::Configuration, password_bean: models::PasswordBean, key: Option<&str>, username: Option<&str>) -> Result<(), Error<ChangeUserPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_password_bean = password_bean;
    let p_key = key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_key {
        req_builder = req_builder.query(&[("key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_password_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeUserPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Converts temporary avatar into a real avatar
pub async fn create_avatar_from_temporary4(configuration: &configuration::Configuration, avatar_cropping_bean: models::AvatarCroppingBean, username: Option<&str>) -> Result<models::AvatarBean, Error<CreateAvatarFromTemporary4Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_avatar_cropping_bean = avatar_cropping_bean;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/avatar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_avatar_cropping_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvatarBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvatarBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAvatarFromTemporary4Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create user. By default created user will not be notified with email. If password field is not set then password will be randomly generated.
pub async fn create_user(configuration: &configuration::Configuration, user_write_bean: models::UserWriteBean) -> Result<models::UserWriteBean, Error<CreateUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_write_bean = user_write_bean;

    let uri_str = format!("{}/api/2/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_user_write_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserWriteBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserWriteBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the default columns for the given user. Admin permission will be required to get columns for a user other than the currently logged in user.
pub async fn default_columns(configuration: &configuration::Configuration, username: Option<&str>) -> Result<serde_json::Value, Error<DefaultColumnsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/api/2/user/columns", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DefaultColumnsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes avatar
pub async fn delete_avatar2(configuration: &configuration::Configuration, id: i64, username: Option<&str>) -> Result<(), Error<DeleteAvatar2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/avatar/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAvatar2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes the property from the user identified by the key or by the id. The user who removes the property is required to have permissions to administer the user.
pub async fn delete_property6(configuration: &configuration::Configuration, property_key: &str, user_key: Option<&str>, username: Option<&str>) -> Result<(), Error<DeleteProperty6Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;
    let p_user_key = user_key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_user_key {
        req_builder = req_builder.query(&[("userKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteProperty6Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Invalidates session of given user.
pub async fn delete_session(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<DeleteSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/api/2/user/session/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of users that match the search string. This resource cannot be accessed anonymously. Please note that this resource should be called with an issue key when a list of assignable users is retrieved. For create only a project key should be supplied. The list of assignable users may be incorrect if it's called with the project key for editing.
pub async fn find_assignable_users1(configuration: &configuration::Configuration, issue_key: Option<&str>, max_results: Option<i32>, project: Option<&str>, action_descriptor_id: Option<i32>, username: Option<&str>) -> Result<models::UserBean, Error<FindAssignableUsers1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_key = issue_key;
    let p_max_results = max_results;
    let p_project = project;
    let p_action_descriptor_id = action_descriptor_id;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/assignable/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_issue_key {
        req_builder = req_builder.query(&[("issueKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_action_descriptor_id {
        req_builder = req_builder.query(&[("actionDescriptorId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindAssignableUsers1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of users that match the search string and can be assigned issues for all the given projects.
pub async fn find_bulk_assignable_users(configuration: &configuration::Configuration, max_results: Option<i32>, project_keys: Option<&str>, username: Option<&str>) -> Result<models::UserBean, Error<FindBulkAssignableUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_max_results = max_results;
    let p_project_keys = project_keys;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/assignable/multiProjectSearch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_project_keys {
        req_builder = req_builder.query(&[("projectKeys", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindBulkAssignableUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Finds users.
pub async fn find_users(configuration: &configuration::Configuration, include_inactive: Option<bool>, max_results: Option<i32>, include_active: Option<bool>, start_at: Option<i32>, username: Option<&str>) -> Result<models::UserBean, Error<FindUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_include_inactive = include_inactive;
    let p_max_results = max_results;
    let p_include_active = include_active;
    let p_start_at = start_at;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_inactive {
        req_builder = req_builder.query(&[("includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_active {
        req_builder = req_builder.query(&[("includeActive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_at {
        req_builder = req_builder.query(&[("startAt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of users matching query with highlighting.
pub async fn find_users_for_picker(configuration: &configuration::Configuration, max_results: Option<i32>, query: Option<&str>, exclude: Option<Vec<String>>, show_avatar: Option<bool>) -> Result<serde_json::Value, Error<FindUsersForPickerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_max_results = max_results;
    let p_query = query;
    let p_exclude = exclude;
    let p_show_avatar = show_avatar;

    let uri_str = format!("{}/api/2/user/picker", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("exclude".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("exclude", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_show_avatar {
        req_builder = req_builder.query(&[("showAvatar", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindUsersForPickerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of active users that match the search string and have all specified permissions for the project or issue. This resource can be accessed by users with ADMINISTER_PROJECT permission for the project or global ADMIN or SYSADMIN rights. This endpoint can cause serious performance issues and will be removed in Jira 9.0.
pub async fn find_users_with_all_permissions(configuration: &configuration::Configuration, project_key: Option<&str>, issue_key: Option<&str>, max_results: Option<i32>, permissions: Option<&str>, start_at: Option<i32>, username: Option<&str>) -> Result<models::UserBean, Error<FindUsersWithAllPermissionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_key = project_key;
    let p_issue_key = issue_key;
    let p_max_results = max_results;
    let p_permissions = permissions;
    let p_start_at = start_at;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/permission/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project_key {
        req_builder = req_builder.query(&[("projectKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_issue_key {
        req_builder = req_builder.query(&[("issueKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_permissions {
        req_builder = req_builder.query(&[("permissions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_at {
        req_builder = req_builder.query(&[("startAt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindUsersWithAllPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of active users that match the search string. This resource cannot be accessed anonymously and requires the Browse Users global permission. Given an issue key this resource will provide a list of users that match the search string and have the browse issue permission for the issue provided.
pub async fn find_users_with_browse_permission(configuration: &configuration::Configuration, project_key: Option<&str>, issue_key: Option<&str>, max_results: Option<i32>, username: Option<&str>) -> Result<models::UserBean, Error<FindUsersWithBrowsePermissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_key = project_key;
    let p_issue_key = issue_key;
    let p_max_results = max_results;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/viewissue/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project_key {
        req_builder = req_builder.query(&[("projectKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_issue_key {
        req_builder = req_builder.query(&[("issueKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindUsersWithBrowsePermissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns available accessibility personal settings along with `enabled` property that indicates the currently logged-in user preference.
pub async fn get_a11y_personal_settings(configuration: &configuration::Configuration, ) -> Result<models::A11yPersonalSettingBean, Error<GetA11yPersonalSettingsError>> {

    let uri_str = format!("{}/api/2/user/a11y/personal-settings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::A11yPersonalSettingBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::A11yPersonalSettingBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetA11yPersonalSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all avatars which are visible for the currently logged in user.
pub async fn get_all_avatars1(configuration: &configuration::Configuration, username: Option<&str>) -> Result<models::AvatarBean, Error<GetAllAvatars1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/api/2/user/avatars", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvatarBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvatarBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllAvatars1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of users that match the search string. This resource cannot be accessed anonymously. Duplicated means that the user has an account in more than one directory and either more than one account is active or the only active account does not belong to the directory with the highest priority. The data returned by this endpoint is cached for 10 minutes and the cache is flushed when any User Directory is added, removed, enabled, disabled, or synchronized. A System Administrator can also flush the cache manually. Related JAC ticket: https://jira.atlassian.com/browse/JRASERVER-68797
pub async fn get_duplicated_users_count(configuration: &configuration::Configuration, flush: Option<bool>) -> Result<models::UserBean, Error<GetDuplicatedUsersCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_flush = flush;

    let uri_str = format!("{}/api/2/user/duplicated/count", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_flush {
        req_builder = req_builder.query(&[("flush", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDuplicatedUsersCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns duplicated users mapped to their directories with an indication if their accounts are active or not. Duplicated means that the user has an account in more than one directory and either more than one account is active or the only active account does not belong to the directory with the highest priority. The data returned by this endpoint is cached for 10 minutes and the cache is flushed when any User Directory is added, removed, enabled, disabled, or synchronized. A System Administrator can also flush the cache manually. Related JAC ticket: https://jira.atlassian.com/browse/JRASERVER-68797
pub async fn get_duplicated_users_mapping(configuration: &configuration::Configuration, flush: Option<bool>) -> Result<models::AvatarBean, Error<GetDuplicatedUsersMappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_flush = flush;

    let uri_str = format!("{}/api/2/user/duplicated/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_flush {
        req_builder = req_builder.query(&[("flush", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvatarBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvatarBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDuplicatedUsersMappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns information about a user anonymization operation progress.
pub async fn get_progress1(configuration: &configuration::Configuration, task_id: Option<i64>) -> Result<(), Error<GetProgress1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;

    let uri_str = format!("{}/api/2/user/anonymization/progress", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_task_id {
        req_builder = req_builder.query(&[("taskId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProgress1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the keys of all properties for the user identified by the key or by the id.
pub async fn get_properties_keys4(configuration: &configuration::Configuration, user_key: Option<&str>, username: Option<&str>) -> Result<(), Error<GetPropertiesKeys4Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_key = user_key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/properties", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_user_key {
        req_builder = req_builder.query(&[("userKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPropertiesKeys4Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the value of the property with a given key from the user identified by the key or by the id.
pub async fn get_property6(configuration: &configuration::Configuration, property_key: &str, user_key: Option<&str>, username: Option<&str>) -> Result<(), Error<GetProperty6Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;
    let p_user_key = user_key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_user_key {
        req_builder = req_builder.query(&[("userKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProperty6Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a user.
pub async fn get_user1(configuration: &configuration::Configuration, include_deleted: Option<bool>, key: Option<&str>, username: Option<&str>) -> Result<models::UserBean, Error<GetUser1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_include_deleted = include_deleted;
    let p_key = key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_deleted {
        req_builder = req_builder.query(&[("includeDeleted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_key {
        req_builder = req_builder.query(&[("key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUser1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes user and its references (like project roles associations, watches, history). Note: user references will not be removed if multiple User Directories are used and there is a user with the same name existing in another directory (shadowing user).
pub async fn remove_user(configuration: &configuration::Configuration, key: Option<&str>, username: Option<&str>) -> Result<(), Error<RemoveUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_key = key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_key {
        req_builder = req_builder.query(&[("key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove user from given application. Admin permission will be required to perform this operation.
pub async fn remove_user_from_application1(configuration: &configuration::Configuration, application_key: Option<&str>, username: Option<&str>) -> Result<(), Error<RemoveUserFromApplication1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_application_key = application_key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/application", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_application_key {
        req_builder = req_builder.query(&[("applicationKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveUserFromApplication1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reset the default columns for the given user to the system default. Admin permission will be required to get columns for a user other than the currently logged in user.
pub async fn reset_columns(configuration: &configuration::Configuration, username: Option<&str>) -> Result<(), Error<ResetColumnsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/api/2/user/columns", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetColumnsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Schedules a user anonymization process. Requires system admin permission.
pub async fn schedule_user_anonymization(configuration: &configuration::Configuration, user_anonymization_request_bean: models::UserAnonymizationRequestBean) -> Result<(), Error<ScheduleUserAnonymizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_anonymization_request_bean = user_anonymization_request_bean;

    let uri_str = format!("{}/api/2/user/anonymization", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_user_anonymization_request_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScheduleUserAnonymizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Schedules a user anonymization process. Requires system admin permission.
pub async fn schedule_user_anonymization_rerun(configuration: &configuration::Configuration, user_anonymization_rerun_request_bean: models::UserAnonymizationRerunRequestBean) -> Result<(), Error<ScheduleUserAnonymizationRerunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_anonymization_rerun_request_bean = user_anonymization_rerun_request_bean;

    let uri_str = format!("{}/api/2/user/anonymization/rerun", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_user_anonymization_rerun_request_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScheduleUserAnonymizationRerunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the default columns for the given user. Admin permission will be required to get columns for a user other than the currently logged in user.
pub async fn set_columns_url_encoded(configuration: &configuration::Configuration, username: Option<&str>, columns: Option<Vec<String>>) -> Result<(), Error<SetColumnsUrlEncodedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_columns = columns;

    let uri_str = format!("{}/api/2/user/columns", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_username {
        multipart_form_params.insert("username", param_value.to_string());
    }
    if let Some(param_value) = p_columns {
        multipart_form_params.insert("columns", param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetColumnsUrlEncodedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the value of the specified user's property. You can use this resource to store a custom data against the user identified by the key or by the id. The user who stores the data is required to have permissions to administer the user.
pub async fn set_property5(configuration: &configuration::Configuration, property_key: &str, user_key: Option<&str>, username: Option<&str>, body: Option<&str>) -> Result<(), Error<SetProperty5Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;
    let p_user_key = user_key;
    let p_username = username;
    let p_body = body;

    let uri_str = format!("{}/api/2/user/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_user_key {
        req_builder = req_builder.query(&[("userKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetProperty5Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from which the client parses the JSON from. Creating a temporary avatar is part of a 3-step process in uploading a new avatar for a user: upload, crop, confirm. This endpoint allows you to use a multipart upload instead of sending the image directly as the request body. You *must* use \"avatar\" as the name of the upload parameter: curl -c cookiejar.txt -X POST -u admin:admin -H \"X-Atlassian-Token: no-check\" \\   -F \"avatar=@mynewavatar.png;type=image/png\" \\   'http://localhost:8090/jira/rest/api/2/user/avatar/temporary?username=admin'
pub async fn store_temporary_avatar_using_multi_part3(configuration: &configuration::Configuration, username: Option<&str>) -> Result<models::AvatarCroppingBean, Error<StoreTemporaryAvatarUsingMultiPart3Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/api/2/user/avatar/temporary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvatarCroppingBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvatarCroppingBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreTemporaryAvatarUsingMultiPart3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes stale user anonymization task, for scenarios when the node that was executing it is no longer alive. Use it only after making sure that the parent node of the task is actually down, and not just having connectivity issues.
pub async fn unlock_anonymization(configuration: &configuration::Configuration, ) -> Result<(), Error<UnlockAnonymizationError>> {

    let uri_str = format!("{}/api/2/user/anonymization/unlock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnlockAnonymizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modify user. The 'value' fields present will override the existing value. Fields skipped in request will not be changed.
pub async fn update_user1(configuration: &configuration::Configuration, user_write_bean: models::UserWriteBean, key: Option<&str>, username: Option<&str>) -> Result<models::UserWriteBean, Error<UpdateUser1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_write_bean = user_write_bean;
    let p_key = key;
    let p_username = username;

    let uri_str = format!("{}/api/2/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_key {
        req_builder = req_builder.query(&[("key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_user_write_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserWriteBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserWriteBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUser1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the avatar for the user.
pub async fn update_user_avatar1(configuration: &configuration::Configuration, avatar_bean: models::AvatarBean, username: Option<&str>) -> Result<models::AvatarBean, Error<UpdateUserAvatar1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_avatar_bean = avatar_bean;
    let p_username = username;

    let uri_str = format!("{}/api/2/user/avatar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_avatar_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvatarBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvatarBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserAvatar1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Validates user anonymization process.
pub async fn validate_user_anonymization(configuration: &configuration::Configuration, expand: Option<&str>, user_key: Option<&str>) -> Result<(), Error<ValidateUserAnonymizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_expand = expand;
    let p_user_key = user_key;

    let uri_str = format!("{}/api/2/user/anonymization", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_user_key {
        req_builder = req_builder.query(&[("userKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidateUserAnonymizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Validates user anonymization re-run process.
pub async fn validate_user_anonymization_rerun(configuration: &configuration::Configuration, expand: Option<&str>, old_user_key: Option<&str>, old_user_name: Option<&str>, user_key: Option<&str>) -> Result<models::UserAnonymizationValidationBean, Error<ValidateUserAnonymizationRerunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_expand = expand;
    let p_old_user_key = old_user_key;
    let p_old_user_name = old_user_name;
    let p_user_key = user_key;

    let uri_str = format!("{}/api/2/user/anonymization/rerun", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_old_user_key {
        req_builder = req_builder.query(&[("oldUserKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_old_user_name {
        req_builder = req_builder.query(&[("oldUserName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_user_key {
        req_builder = req_builder.query(&[("userKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserAnonymizationValidationBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserAnonymizationValidationBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidateUserAnonymizationRerunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

