/*
 * Jira Software Data Center REST API Reference
 *
 * This is the reference document for the REST API and resources provided by Jira Software Data Center. The REST APIs are for developers who want to integrate Jira Data Center with other applications, and for administrators who want to script configuration interactions with Jira Data Center.  Jira Data Center is built upon the Jira platform.  As such there is a natural overlap in functionality between what is provided by Jira Data Center and what is provided by the Jira platform.  If you are after an introductory, high-level view of the Jira REST APIs, then the best place to start is the [Jira REST API home](https://developer.atlassian.com/server/jira/platform/rest-apis/). ## Using the REST API Not familiar with the Jira Data Center REST APIs? Start with our [Guide to exploring the Jira Data Center domain model via the REST APIs](https://developer.atlassian.com/server/jira/platform/tutorials_and_guides/), which will help you get a conceptual understanding of the Jira Data Center REST APIs.  If you want instructions on how to use the REST APIs, check out the [Appendix](#appendix) at the end of this page (after the resources), where you'll find information on the following topics: * [Structure of the REST URIs](#structure) * [Authentication](#authentication) * [Pagination](#pagination) * [Expansion](#expansion) * [Special headers](#special-headers) * [Field input formats](#fieldformats) ### Experimental methods Methods marked as `EXPERIMENTAL` may change without notice. We are looking for your feedback for these methods. To use experimental methods, you must set this header in your requests: `X-ExperimentalApi : true`. This indicates that you are opting into the experimental preview. Once a resource or method moves out of the experimental phase, then this header will no longer be required nor checked. 
 *
 * The version of the OpenAPI document: swagger-merged-template.yaml
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddAttachmentError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddCommentError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_vote`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddVoteError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_watcher1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddWatcher1Error {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_worklog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddWorklogError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`archive_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArchiveIssueError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`archive_issues`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArchiveIssuesError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`assign`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssignError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`can_move_sub_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CanMoveSubTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIssueError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_issues`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIssuesError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_or_update_remote_issue_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrUpdateRemoteIssueLinkError {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_reciprocal_remote_issue_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateReciprocalRemoteIssueLinkError {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCommentError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIssueError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_property3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteProperty3Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_remote_issue_link_by_global_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRemoteIssueLinkByGlobalIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_remote_issue_link_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRemoteIssueLinkByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_worklog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorklogError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`do_transition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DoTransitionError {
    Status400(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditIssueError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`estimate_issue_for_board`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EstimateIssueForBoardError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentsError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_create_issue_meta_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCreateIssueMetaFieldsError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_create_issue_meta_project_issue_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCreateIssueMetaProjectIssueTypesError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_edit_issue_meta`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEditIssueMetaError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIssueError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_issue_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIssue0Error {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_issue_estimation_for_board`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIssueEstimationForBoardError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_issue_picker_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIssuePickerResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_issue_watchers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIssueWatchersError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_issue_worklog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIssueWorklogError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pinned_comments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPinnedCommentsError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_properties_keys2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPropertiesKeys2Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_property3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProperty3Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_remote_issue_link_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRemoteIssueLinkByIdError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_remote_issue_links`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRemoteIssueLinksError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubTasksError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransitionsError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_votes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVotesError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worklog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorklogError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_sub_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveSubTasksError {
    Status400(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notify`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotifyError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rank_issues`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RankIssuesError {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_vote`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveVoteError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_watcher1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveWatcher1Error {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`restore_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestoreIssueError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_pin_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetPinCommentError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_property2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetProperty2Error {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCommentError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_remote_issue_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRemoteIssueLinkError {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_worklog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorklogError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}


/// Add one or more attachments to an issue. This resource expects a multipart post. The media-type multipart/form-data is defined in RFC 1867. Most client libraries have classes that make dealing with multipart posts simple. For instance, in Java the Apache HTTP Components library provides a MultiPartEntity that makes it simple to submit a multipart POST. In order to protect against XSRF attacks, because this method accepts multipart/form-data, it has XSRF protection on it. This means you must submit a header of X-Atlassian-Token: no-check with the request, otherwise it will be blocked. The name of the multipart/form-data parameter that contains attachments must be file. A simple example to upload a file called \"myfile.txt\" to issue TEST-123: curl -D- -u admin:admin -X POST -H \"X-Atlassian-Token: no-check\" -F \"file=@myfile.txt\" http://myhost/rest/api/2/issue/TEST-123/attachments
pub async fn add_attachment(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<models::AttachmentJsonBean, Error<AddAttachmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/attachments", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AttachmentJsonBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AttachmentJsonBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddAttachmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a new comment to an issue.
pub async fn add_comment(configuration: &configuration::Configuration, issue_id_or_key: &str, expand: Option<&str>, comment_json_bean: Option<models::CommentJsonBean>) -> Result<models::CommentJsonBean, Error<AddCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_expand = expand;
    let p_comment_json_bean = comment_json_bean;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/comment", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_comment_json_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommentJsonBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommentJsonBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds voter (currently logged user) to particular ticket. You need to be logged in to use this method.
pub async fn add_vote(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<(), Error<AddVoteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/votes", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddVoteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a user to an issue's watcher list.
pub async fn add_watcher1(configuration: &configuration::Configuration, issue_id_or_key: &str, user_name: Option<&str>, body: Option<&str>) -> Result<(), Error<AddWatcher1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_user_name = user_name;
    let p_body = body;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/watchers", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_user_name {
        req_builder = req_builder.query(&[("userName", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddWatcher1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a new worklog entry to an issue.
pub async fn add_worklog(configuration: &configuration::Configuration, issue_id_or_key: &str, new_estimate: Option<&str>, adjust_estimate: Option<&str>, reduce_by: Option<&str>, worklog: Option<models::Worklog>) -> Result<models::Worklog, Error<AddWorklogError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_new_estimate = new_estimate;
    let p_adjust_estimate = adjust_estimate;
    let p_reduce_by = reduce_by;
    let p_worklog = worklog;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/worklog", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_new_estimate {
        req_builder = req_builder.query(&[("newEstimate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_adjust_estimate {
        req_builder = req_builder.query(&[("adjustEstimate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reduce_by {
        req_builder = req_builder.query(&[("reduceBy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_worklog);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Worklog`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Worklog`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddWorklogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Archives an issue.
pub async fn archive_issue(configuration: &configuration::Configuration, issue_id_or_key: &str, notify_users: Option<&str>) -> Result<(), Error<ArchiveIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_notify_users = notify_users;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/archive", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_notify_users {
        req_builder = req_builder.query(&[("notifyUsers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ArchiveIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Archives a list of issues.
pub async fn archive_issues(configuration: &configuration::Configuration, notify_users: Option<&str>, body: Option<&str>) -> Result<serde_json::Value, Error<ArchiveIssuesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_notify_users = notify_users;
    let p_body = body;

    let uri_str = format!("{}/api/2/issue/archive", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_notify_users {
        req_builder = req_builder.query(&[("notifyUsers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ArchiveIssuesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign an issue to a user.
pub async fn assign(configuration: &configuration::Configuration, issue_id_or_key: &str, user_bean: Option<models::UserBean>) -> Result<(), Error<AssignError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_user_bean = user_bean;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/assignee", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_user_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AssignError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checks if a subtask can be moved
pub async fn can_move_sub_task(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<bool, Error<CanMoveSubTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/subtask/move", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CanMoveSubTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an issue or a sub-task from a JSON representation. The fields that can be set on create, in either the fields parameter or the update parameter can be determined using the /rest/api/2/issue/createmeta resource. If a field is not configured to appear on the create screen, then it will not be in the createmeta, and a field validation error will occur if it is submitted. Creating a sub-task is similar to creating a regular issue, with two important differences: - the issueType field must correspond to a sub-task issue type (you can use /issue/createmeta to discover sub-task issue types), and - you must provide a parent field in the issue create request containing the id or key of the parent issue. The updateHistory param adds the project that this issue is created in, to the current user's project history, if set to true (by default, the project history is not updated). You can view the project history in the Jira application, via the Projects dropdown.
pub async fn create_issue(configuration: &configuration::Configuration, update_history: Option<bool>, issue_update_bean: Option<models::IssueUpdateBean>) -> Result<models::IssueCreateResponse, Error<CreateIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_history = update_history;
    let p_issue_update_bean = issue_update_bean;

    let uri_str = format!("{}/api/2/issue", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_update_history {
        req_builder = req_builder.query(&[("updateHistory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_issue_update_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates issues or sub-tasks from a JSON representation. Creates many issues in one bulk operation. Creating a sub-task is similar to creating a regular issue. More details can be found in createIssue section.
pub async fn create_issues(configuration: &configuration::Configuration, issues_update_bean: Option<models::IssuesUpdateBean>) -> Result<models::IssuesCreateResponse, Error<CreateIssuesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issues_update_bean = issues_update_bean;

    let uri_str = format!("{}/api/2/issue/bulk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_issues_update_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssuesCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssuesCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIssuesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates or updates a remote issue link from a JSON representation. If a globalId is provided and a remote issue link exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.
pub async fn create_or_update_remote_issue_link(configuration: &configuration::Configuration, issue_id_or_key: &str, remote_issue_link_create_or_update_request: Option<models::RemoteIssueLinkCreateOrUpdateRequest>) -> Result<serde_json::Value, Error<CreateOrUpdateRemoteIssueLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_remote_issue_link_create_or_update_request = remote_issue_link_create_or_update_request;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/remotelink", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_remote_issue_link_create_or_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrUpdateRemoteIssueLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create reciprocal remote issue link from a JSON representation. Jira will create two issue links, source -> target and target -> source.
pub async fn create_reciprocal_remote_issue_link(configuration: &configuration::Configuration, remote_reciprocal_issue_link_create_request: Option<models::RemoteReciprocalIssueLinkCreateRequest>) -> Result<models::RemoteReciprocalIssueLinkCreateResponse, Error<CreateReciprocalRemoteIssueLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_remote_reciprocal_issue_link_create_request = remote_reciprocal_issue_link_create_request;

    let uri_str = format!("{}/api/2/issue/remotelink/reciprocal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_remote_reciprocal_issue_link_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RemoteReciprocalIssueLinkCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RemoteReciprocalIssueLinkCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateReciprocalRemoteIssueLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an existing comment.
pub async fn delete_comment(configuration: &configuration::Configuration, issue_id_or_key: &str, id: &str) -> Result<(), Error<DeleteCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_id = id;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/comment/{id}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an issue. If the issue has subtasks you must set the parameter deleteSubtasks=true to delete the issue. You cannot delete an issue without its subtasks also being deleted.
pub async fn delete_issue(configuration: &configuration::Configuration, issue_id_or_key: &str, delete_subtasks: Option<&str>) -> Result<(), Error<DeleteIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_delete_subtasks = delete_subtasks;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_delete_subtasks {
        req_builder = req_builder.query(&[("deleteSubtasks", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes the property from the issue identified by the key or by the id.
pub async fn delete_property3(configuration: &configuration::Configuration, property_key: &str, issue_id_or_key: &str) -> Result<(), Error<DeleteProperty3Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key), issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteProperty3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete the remote issue link with the given global id on the issue.
pub async fn delete_remote_issue_link_by_global_id(configuration: &configuration::Configuration, issue_id_or_key: &str, global_id: &str) -> Result<(), Error<DeleteRemoteIssueLinkByGlobalIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_global_id = global_id;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/remotelink", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("globalId", &p_global_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRemoteIssueLinkByGlobalIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete the remote issue link with the given id on the issue.
pub async fn delete_remote_issue_link_by_id(configuration: &configuration::Configuration, link_id: &str, issue_id_or_key: &str) -> Result<(), Error<DeleteRemoteIssueLinkByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_link_id = link_id;
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/remotelink/{linkId}", configuration.base_path, linkId=crate::apis::urlencode(p_link_id), issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRemoteIssueLinkByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an existing worklog entry.
pub async fn delete_worklog(configuration: &configuration::Configuration, issue_id_or_key: &str, id: &str, new_estimate: Option<&str>, adjust_estimate: Option<&str>, increase_by: Option<&str>) -> Result<(), Error<DeleteWorklogError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_id = id;
    let p_new_estimate = new_estimate;
    let p_adjust_estimate = adjust_estimate;
    let p_increase_by = increase_by;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/worklog/{id}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_new_estimate {
        req_builder = req_builder.query(&[("newEstimate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_adjust_estimate {
        req_builder = req_builder.query(&[("adjustEstimate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_increase_by {
        req_builder = req_builder.query(&[("increaseBy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWorklogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Perform a transition on an issue. When performing the transition you can update or set other issue fields. The fields that can be set on transition, in either the fields parameter or the update parameter can be determined using the /rest/api/2/issue/{issueIdOrKey}/transitions?expand=transitions.fields resource. If a field is not configured to appear on the transition screen, then it will not be in the transition metadata, and a field validation error will occur if it is submitted. The updateHistory param adds the issues retrieved by this method to the current user's issue history, if set to true (by default, the issue history does not include issues retrieved via the REST API). You can view the issue history in the Jira application, via the Issues dropdown or by using the lastViewed JQL field in an issue search.
pub async fn do_transition(configuration: &configuration::Configuration, issue_id_or_key: &str, issue_update_bean: Option<models::IssueUpdateBean>) -> Result<(), Error<DoTransitionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_issue_update_bean = issue_update_bean;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/transitions", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_issue_update_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DoTransitionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Edits an issue from a JSON representation. The issue can either be updated by setting explicit the field value(s) or by using an operation to change the field value.
pub async fn edit_issue(configuration: &configuration::Configuration, issue_id_or_key: &str, notify_users: Option<&str>, issue_update_bean: Option<models::IssueUpdateBean>) -> Result<(), Error<EditIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_notify_users = notify_users;
    let p_issue_update_bean = issue_update_bean;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_notify_users {
        req_builder = req_builder.query(&[("notifyUsers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_issue_update_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EditIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the estimation of the issue. boardId param is required. This param determines which field will be updated on a issue. Note that this resource changes the estimation field of the issue regardless of appearance the field on the screen. Original time tracking estimation field accepts estimation in formats like \"1w\", \"2d\", \"3h\", \"20m\" or number which represent number of minutes. However, internally the field stores and returns the estimation as a number of seconds. The field used for estimation on the given board can be obtained from <a href=\"#agile/1.0/board-getConfiguration\">board configuration resource</a>. More information about the field are returned by edit meta resource or field resource.
pub async fn estimate_issue_for_board(configuration: &configuration::Configuration, issue_id_or_key: &str, field_edit_bean: models::FieldEditBean, board_id: Option<i64>) -> Result<models::FieldValueBean, Error<EstimateIssueForBoardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_field_edit_bean = field_edit_bean;
    let p_board_id = board_id;

    let uri_str = format!("{}/agile/1.0/issue/{issueIdOrKey}/estimation", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_board_id {
        req_builder = req_builder.query(&[("boardId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_field_edit_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FieldValueBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FieldValueBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EstimateIssueForBoardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a single comment.
pub async fn get_comment(configuration: &configuration::Configuration, issue_id_or_key: &str, id: &str, expand: Option<&str>) -> Result<models::CommentJsonBean, Error<GetCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_id = id;
    let p_expand = expand;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/comment/{id}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommentJsonBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommentJsonBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all comments for an issue. Results can be ordered by the 'created' field which means the date a comment was added.
pub async fn get_comments(configuration: &configuration::Configuration, issue_id_or_key: &str, expand: Option<&str>, max_results: Option<&str>, order_by: Option<&str>, start_at: Option<&str>) -> Result<models::CommentsWithPaginationJsonBean, Error<GetCommentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_expand = expand;
    let p_max_results = max_results;
    let p_order_by = order_by;
    let p_start_at = start_at;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/comment", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("orderBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_at {
        req_builder = req_builder.query(&[("startAt", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommentsWithPaginationJsonBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommentsWithPaginationJsonBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the metadata for issue types used for creating issues. Data will not be returned if the user does not have permission to create issues in that project.
pub async fn get_create_issue_meta_fields(configuration: &configuration::Configuration, issue_type_id: &str, project_id_or_key: &str, max_results: Option<&str>, start_at: Option<&str>) -> Result<models::FieldMetaBean, Error<GetCreateIssueMetaFieldsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_type_id = issue_type_id;
    let p_project_id_or_key = project_id_or_key;
    let p_max_results = max_results;
    let p_start_at = start_at;

    let uri_str = format!("{}/api/2/issue/createmeta/{projectIdOrKey}/issuetypes/{issueTypeId}", configuration.base_path, issueTypeId=crate::apis::urlencode(p_issue_type_id), projectIdOrKey=crate::apis::urlencode(p_project_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_at {
        req_builder = req_builder.query(&[("startAt", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FieldMetaBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FieldMetaBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCreateIssueMetaFieldsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the metadata for issue types used for creating issues. Data will not be returned if the user does not have permission to create issues in that project.
pub async fn get_create_issue_meta_project_issue_types(configuration: &configuration::Configuration, project_id_or_key: &str, max_results: Option<&str>, start_at: Option<&str>) -> Result<models::CreateMetaIssueTypeBean, Error<GetCreateIssueMetaProjectIssueTypesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id_or_key = project_id_or_key;
    let p_max_results = max_results;
    let p_start_at = start_at;

    let uri_str = format!("{}/api/2/issue/createmeta/{projectIdOrKey}/issuetypes", configuration.base_path, projectIdOrKey=crate::apis::urlencode(p_project_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_at {
        req_builder = req_builder.query(&[("startAt", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMetaIssueTypeBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMetaIssueTypeBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCreateIssueMetaProjectIssueTypesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the meta data for editing an issue. The fields in the editmeta correspond to the fields in the edit screen for the issue. Fields not in the screen will not be in the editmeta.
pub async fn get_edit_issue_meta(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<serde_json::Value, Error<GetEditIssueMetaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/editmeta", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEditIssueMetaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a single issue, for a given issue Id or issue key. Issues returned from this resource include Agile fields, like sprint, closedSprints, flagged, and epic.
pub async fn get_issue(configuration: &configuration::Configuration, issue_id_or_key: &str, expand: Option<&str>, fields: Option<Vec<serde_json::Value>>, update_history: Option<bool>) -> Result<models::IssueBean, Error<GetIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_expand = expand;
    let p_fields = fields;
    let p_update_history = update_history;

    let uri_str = format!("{}/agile/1.0/issue/{issueIdOrKey}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fields {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("fields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("fields", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_update_history {
        req_builder = req_builder.query(&[("updateHistory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a full representation of the issue for the given issue key. An issue JSON consists of the issue key, a collection of fields, a link to the workflow transition sub-resource, and (optionally) the HTML rendered values of any fields that support it (e.g. if wiki syntax is enabled for the description or comments). The fields param (which can be specified multiple times) gives a comma-separated list of fields to include in the response. This can be used to retrieve a subset of fields. A particular field can be excluded by prefixing it with a minus. By default, all (*all) fields are returned in this get-issue resource. Note: the default is different when doing a jql search -- the default there is just navigable fields (*navigable). - *all - include all fields - *navigable - include just navigable fields - summary,comment - include just the summary and comments - -comment - include everything except comments (the default is *all for get-issue) - *all,-comment - include everything except comments  The {@code properties} param is similar to {@code fields} and specifies a comma-separated list of issue properties to include. Unlike {@code fields}, properties are not included by default. To include them all send {@code ?properties=*all}. You can also include only specified properties or exclude some properties with a minus (-) sign.  - {@code *all} - include all properties - {@code *all, -prop1} - include all properties except {@code prop1} - {@code prop1, prop1} - include {@code prop1} and {@code prop2} properties  Jira will attempt to identify the issue by the issueIdOrKey path parameter. This can be an issue id, or an issue key. If the issue cannot be found via an exact match, Jira will also look for the issue in a case-insensitive way, by looking to see if the issue was moved. In either of these cases, the request will proceed as normal (a 302 or other redirect will not be returned). The issue key contained in the response will indicate the current value of issue's key.  The expand param is used to include, hidden by default, parts of response. This can be used to include:  - renderedFields - field values in HTML format - names - display name of each field - schema - schema for each field which describes a type of the field - transitions - all possible transitions for the given issue - operations - all possibles operations which may be applied on issue - editmeta - information about how each field may be edited. It contains field's schema as well. - changelog - history of all changes of the given issue - versionedRepresentations - REST representations of all fields. Some field may contain more recent versions. RESET representations are numbered. The greatest number always represents the most recent version. It is recommended that the most recent version is used. version for these fields which provide a more recent REST representation. After including versionedRepresentations \"fields\" field become hidden.
pub async fn get_issue_0(configuration: &configuration::Configuration, issue_id_or_key: &str, expand: Option<&str>, fields: Option<&str>, update_history: Option<&str>, properties: Option<&str>) -> Result<models::IssueBean, Error<GetIssue0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_expand = expand;
    let p_fields = fields;
    let p_update_history = update_history;
    let p_properties = properties;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fields {
        req_builder = req_builder.query(&[("fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_update_history {
        req_builder = req_builder.query(&[("updateHistory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_properties {
        req_builder = req_builder.query(&[("properties", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIssue0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the estimation of the issue and a fieldId of the field that is used for it. Original time internally stores and returns the estimation as a number of seconds. The field used for estimation on the given board can be obtained from board configuration resource. More information about the field are returned by edit meta resource or field resource.
pub async fn get_issue_estimation_for_board(configuration: &configuration::Configuration, issue_id_or_key: &str, board_id: Option<i64>) -> Result<models::FieldValueBean, Error<GetIssueEstimationForBoardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_board_id = board_id;

    let uri_str = format!("{}/agile/1.0/issue/{issueIdOrKey}/estimation", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_board_id {
        req_builder = req_builder.query(&[("boardId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FieldValueBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FieldValueBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIssueEstimationForBoardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get issue picker resource
pub async fn get_issue_picker_resource(configuration: &configuration::Configuration, current_project_id: Option<&str>, query: Option<&str>, current_issue_key: Option<&str>, show_sub_tasks: Option<&str>, current_jql: Option<&str>, show_sub_task_parent: Option<&str>) -> Result<models::IssuePickerResult, Error<GetIssuePickerResourceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_current_project_id = current_project_id;
    let p_query = query;
    let p_current_issue_key = current_issue_key;
    let p_show_sub_tasks = show_sub_tasks;
    let p_current_jql = current_jql;
    let p_show_sub_task_parent = show_sub_task_parent;

    let uri_str = format!("{}/api/2/issue/picker", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_current_project_id {
        req_builder = req_builder.query(&[("currentProjectId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_current_issue_key {
        req_builder = req_builder.query(&[("currentIssueKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_show_sub_tasks {
        req_builder = req_builder.query(&[("showSubTasks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_current_jql {
        req_builder = req_builder.query(&[("currentJQL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_show_sub_task_parent {
        req_builder = req_builder.query(&[("showSubTaskParent", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssuePickerResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssuePickerResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIssuePickerResourceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the list of watchers for the issue with the given key.
pub async fn get_issue_watchers(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<serde_json::Value, Error<GetIssueWatchersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/watchers", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIssueWatchersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all work logs for an issue. Work logs won't be returned if the Log work field is hidden for the project.
pub async fn get_issue_worklog(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<models::WorklogWithPaginationBean, Error<GetIssueWorklogError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/worklog", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorklogWithPaginationBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorklogWithPaginationBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIssueWorklogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all pinned to the issue comments.
pub async fn get_pinned_comments(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<models::PinnedCommentJsonBean, Error<GetPinnedCommentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/pinned-comments", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PinnedCommentJsonBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PinnedCommentJsonBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPinnedCommentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the keys of all properties for the issue identified by the key or by the id.
pub async fn get_properties_keys2(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<models::EntityPropertiesKeysBean, Error<GetPropertiesKeys2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/properties", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityPropertiesKeysBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityPropertiesKeysBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPropertiesKeys2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the value of the property with a given key from the issue identified by the key or by the id.
pub async fn get_property3(configuration: &configuration::Configuration, property_key: &str, issue_id_or_key: &str) -> Result<models::EntityPropertyBean, Error<GetProperty3Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key), issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityPropertyBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityPropertyBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProperty3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a remote issue link by its id.
pub async fn get_remote_issue_link_by_id(configuration: &configuration::Configuration, link_id: &str, issue_id_or_key: &str) -> Result<serde_json::Value, Error<GetRemoteIssueLinkByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_link_id = link_id;
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/remotelink/{linkId}", configuration.base_path, linkId=crate::apis::urlencode(p_link_id), issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRemoteIssueLinkByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get remote issue links for an issue.
pub async fn get_remote_issue_links(configuration: &configuration::Configuration, issue_id_or_key: &str, global_id: Option<&str>) -> Result<serde_json::Value, Error<GetRemoteIssueLinksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_global_id = global_id;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/remotelink", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_global_id {
        req_builder = req_builder.query(&[("globalId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRemoteIssueLinksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns an issue's subtask list
pub async fn get_sub_tasks(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<models::IssueRefJsonBean, Error<GetSubTasksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/subtask", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueRefJsonBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueRefJsonBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubTasksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of the transitions possible for this issue by the current user, along with fields that are required and their types. Fields will only be returned if `expand=transitions.fields`. The fields in the metadata correspond to the fields in the transition screen for that transition. Fields not in the screen will not be in the metadata.
pub async fn get_transitions(configuration: &configuration::Configuration, issue_id_or_key: &str, transition_id: Option<&str>) -> Result<models::TransitionsMetaBean, Error<GetTransitionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_transition_id = transition_id;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/transitions", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_transition_id {
        req_builder = req_builder.query(&[("transitionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransitionsMetaBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransitionsMetaBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransitionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A REST sub-resource representing the voters on the issue.
pub async fn get_votes(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<serde_json::Value, Error<GetVotesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/votes", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVotesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a specific worklog. The work log won't be returned if the Log work field is hidden for the project.
pub async fn get_worklog(configuration: &configuration::Configuration, issue_id_or_key: &str, id: &str) -> Result<models::Worklog, Error<GetWorklogError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_id = id;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/worklog/{id}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Worklog`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Worklog`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorklogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reorders an issue's subtasks by moving the subtask at index 'from' to index 'to'.
pub async fn move_sub_tasks(configuration: &configuration::Configuration, issue_id_or_key: &str, issue_sub_task_move_position_bean: models::IssueSubTaskMovePositionBean) -> Result<(), Error<MoveSubTasksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_issue_sub_task_move_position_bean = issue_sub_task_move_position_bean;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/subtask/move", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_issue_sub_task_move_position_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveSubTasksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a notification (email) to the list or recipients defined in the request.
pub async fn notify(configuration: &configuration::Configuration, issue_id_or_key: &str, notification_json_bean: Option<models::NotificationJsonBean>) -> Result<(), Error<NotifyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_notification_json_bean = notification_json_bean;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/notify", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_notification_json_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<NotifyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Moves (ranks) issues before or after a given issue. At most 50 issues may be ranked at once. This operation may fail for some issues, although this will be rare. In that case the 207 status code is returned for the whole response and detailed information regarding each issue is available in the response body. If rankCustomFieldId is not defined, the default rank field will be used.
pub async fn rank_issues(configuration: &configuration::Configuration, issue_rank_request_bean: models::IssueRankRequestBean) -> Result<(), Error<RankIssuesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_rank_request_bean = issue_rank_request_bean;

    let uri_str = format!("{}/agile/1.0/issue/rank", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_issue_rank_request_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RankIssuesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove your vote from an issue.
pub async fn remove_vote(configuration: &configuration::Configuration, issue_id_or_key: &str) -> Result<(), Error<RemoveVoteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/votes", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveVoteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a user from an issue's watcher list.
pub async fn remove_watcher1(configuration: &configuration::Configuration, issue_id_or_key: &str, user_name: Option<&str>, username: Option<&str>) -> Result<(), Error<RemoveWatcher1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_user_name = user_name;
    let p_username = username;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/watchers", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_user_name {
        req_builder = req_builder.query(&[("userName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveWatcher1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restores an archived issue.
pub async fn restore_issue(configuration: &configuration::Configuration, issue_id_or_key: &str, notify_users: Option<&str>) -> Result<(), Error<RestoreIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_notify_users = notify_users;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/restore", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_notify_users {
        req_builder = req_builder.query(&[("notifyUsers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RestoreIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Pins a comment to the top of the comment list.
pub async fn set_pin_comment(configuration: &configuration::Configuration, issue_id_or_key: &str, id: &str, body: bool) -> Result<(), Error<SetPinCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_id = id;
    let p_body = body;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/comment/{id}/pin", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetPinCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the value of the specified issue's property.
pub async fn set_property2(configuration: &configuration::Configuration, property_key: &str, issue_id_or_key: &str, body: &str) -> Result<(), Error<SetProperty2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;
    let p_issue_id_or_key = issue_id_or_key;
    let p_body = body;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key), issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetProperty2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an existing comment using its JSON representation.
pub async fn update_comment(configuration: &configuration::Configuration, issue_id_or_key: &str, id: &str, expand: Option<&str>, comment_json_bean: Option<models::CommentJsonBean>) -> Result<models::CommentJsonBean, Error<UpdateCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_id = id;
    let p_expand = expand;
    let p_comment_json_bean = comment_json_bean;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/comment/{id}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_comment_json_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommentJsonBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommentJsonBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a remote issue link from a JSON representation. Any fields not provided are set to null.
pub async fn update_remote_issue_link(configuration: &configuration::Configuration, link_id: &str, issue_id_or_key: &str, remote_issue_link_create_or_update_request: Option<models::RemoteIssueLinkCreateOrUpdateRequest>) -> Result<(), Error<UpdateRemoteIssueLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_link_id = link_id;
    let p_issue_id_or_key = issue_id_or_key;
    let p_remote_issue_link_create_or_update_request = remote_issue_link_create_or_update_request;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/remotelink/{linkId}", configuration.base_path, linkId=crate::apis::urlencode(p_link_id), issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_remote_issue_link_create_or_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateRemoteIssueLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an existing worklog entry. Note that: - Fields possible for editing are: comment, visibility, started, timeSpent and timeSpentSeconds. - Either timeSpent or timeSpentSeconds can be set. - Fields which are not set will not be updated. - For a request to be valid, it has to have at least one field change.
pub async fn update_worklog(configuration: &configuration::Configuration, issue_id_or_key: &str, id: &str, new_estimate: Option<&str>, adjust_estimate: Option<&str>, worklog: Option<models::Worklog>) -> Result<models::Worklog, Error<UpdateWorklogError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_id_or_key = issue_id_or_key;
    let p_id = id;
    let p_new_estimate = new_estimate;
    let p_adjust_estimate = adjust_estimate;
    let p_worklog = worklog;

    let uri_str = format!("{}/api/2/issue/{issueIdOrKey}/worklog/{id}", configuration.base_path, issueIdOrKey=crate::apis::urlencode(p_issue_id_or_key), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_new_estimate {
        req_builder = req_builder.query(&[("newEstimate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_adjust_estimate {
        req_builder = req_builder.query(&[("adjustEstimate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_worklog);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Worklog`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Worklog`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateWorklogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

