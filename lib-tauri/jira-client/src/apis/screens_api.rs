/*
 * Jira Software Data Center REST API Reference
 *
 * This is the reference document for the REST API and resources provided by Jira Software Data Center. The REST APIs are for developers who want to integrate Jira Data Center with other applications, and for administrators who want to script configuration interactions with Jira Data Center.  Jira Data Center is built upon the Jira platform.  As such there is a natural overlap in functionality between what is provided by Jira Data Center and what is provided by the Jira platform.  If you are after an introductory, high-level view of the Jira REST APIs, then the best place to start is the [Jira REST API home](https://developer.atlassian.com/server/jira/platform/rest-apis/). ## Using the REST API Not familiar with the Jira Data Center REST APIs? Start with our [Guide to exploring the Jira Data Center domain model via the REST APIs](https://developer.atlassian.com/server/jira/platform/tutorials_and_guides/), which will help you get a conceptual understanding of the Jira Data Center REST APIs.  If you want instructions on how to use the REST APIs, check out the [Appendix](#appendix) at the end of this page (after the resources), where you'll find information on the following topics: * [Structure of the REST URIs](#structure) * [Authentication](#authentication) * [Pagination](#pagination) * [Expansion](#expansion) * [Special headers](#special-headers) * [Field input formats](#fieldformats) ### Experimental methods Methods marked as `EXPERIMENTAL` may change without notice. We are looking for your feedback for these methods. To use experimental methods, you must set this header in your requests: `X-ExperimentalApi : true`. This indicates that you are opting into the experimental preview. Once a resource or method moves out of the experimental phase, then this header will no longer be required nor checked. 
 *
 * The version of the OpenAPI document: swagger-merged-template.yaml
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddFieldError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_field_to_default_screen`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddFieldToDefaultScreenError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_tab`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddTabError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tab`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTabError {
    Status400(),
    Status401(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllFieldsError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_screens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllScreensError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_tabs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllTabsError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_fields_to_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFieldsToAddError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveFieldError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_tab`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveTabError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveFieldError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rename_tab`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RenameTabError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_show_when_empty_indicator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateShowWhenEmptyIndicatorError {
    Status400(),
    Status401(),
    UnknownValue(serde_json::Value),
}


/// Adds field to the given tab.
pub async fn add_field(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64, add_field_bean: Option<models::AddFieldBean>) -> Result<models::ScreenableFieldBean, Error<AddFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;
    let p_add_field_bean = add_field_bean;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}/fields", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_add_field_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenableFieldBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenableFieldBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Moves field on the given tab.
pub async fn add_field_to_default_screen(configuration: &configuration::Configuration, field_id: &str) -> Result<(), Error<AddFieldToDefaultScreenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_field_id = field_id;

    let uri_str = format!("{}/api/2/screens/addToDefault/{fieldId}", configuration.base_path, fieldId=crate::apis::urlencode(p_field_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddFieldToDefaultScreenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates tab for given screen.
pub async fn add_tab(configuration: &configuration::Configuration, screen_id: i64, screenable_tab_bean: Option<models::ScreenableTabBean>) -> Result<models::ScreenableTabBean, Error<AddTabError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_screen_id = screen_id;
    let p_screenable_tab_bean = screenable_tab_bean;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs", configuration.base_path, screenId=p_screen_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_screenable_tab_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenableTabBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenableTabBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddTabError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes tab from given screen.
pub async fn delete_tab(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64) -> Result<(), Error<DeleteTabError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTabError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets all fields for a given tab.
pub async fn get_all_fields(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64, project_key: Option<&str>) -> Result<models::ScreenableFieldBean, Error<GetAllFieldsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;
    let p_project_key = project_key;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}/fields", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project_key {
        req_builder = req_builder.query(&[("projectKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenableFieldBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenableFieldBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllFieldsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds field or custom field to the default tab.
pub async fn get_all_screens(configuration: &configuration::Configuration, search: Option<&str>, expand: Option<&str>, max_results: Option<&str>, start_at: Option<&str>) -> Result<(), Error<GetAllScreensError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_search = search;
    let p_expand = expand;
    let p_max_results = max_results;
    let p_start_at = start_at;

    let uri_str = format!("{}/api/2/screens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_expand {
        req_builder = req_builder.query(&[("expand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_results {
        req_builder = req_builder.query(&[("maxResults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_at {
        req_builder = req_builder.query(&[("startAt", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllScreensError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of all tabs for the given screen.
pub async fn get_all_tabs(configuration: &configuration::Configuration, screen_id: i64, project_key: Option<&str>) -> Result<models::ScreenableTabBean, Error<GetAllTabsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_screen_id = screen_id;
    let p_project_key = project_key;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs", configuration.base_path, screenId=p_screen_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project_key {
        req_builder = req_builder.query(&[("projectKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenableTabBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenableTabBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllTabsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets available fields for screen. i.e ones that haven't already been added.
pub async fn get_fields_to_add(configuration: &configuration::Configuration, screen_id: i64) -> Result<models::ScreenableFieldBean, Error<GetFieldsToAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_screen_id = screen_id;

    let uri_str = format!("{}/api/2/screens/{screenId}/availableFields", configuration.base_path, screenId=p_screen_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenableFieldBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenableFieldBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFieldsToAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Moves field on the given tab.
pub async fn move_field(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64, id: &str, move_field_bean: Option<models::MoveFieldBean>) -> Result<(), Error<MoveFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;
    let p_id = id;
    let p_move_field_bean = move_field_bean;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}/move", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_move_field_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Moves tab position.
pub async fn move_tab(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64, pos: i32) -> Result<(), Error<MoveTabError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;
    let p_pos = pos;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}/move/{pos}", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id, pos=p_pos);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveTabError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes field from given tab.
pub async fn remove_field(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64, id: &str) -> Result<(), Error<RemoveFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;
    let p_id = id;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Renames tab on given screen.
pub async fn rename_tab(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64, screenable_tab_bean: Option<models::ScreenableTabBean>) -> Result<models::ScreenableTabBean, Error<RenameTabError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;
    let p_screenable_tab_bean = screenable_tab_bean;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_screenable_tab_bean);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenableTabBean`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenableTabBean`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RenameTabError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update 'showWhenEmptyIndicator' for given field on screen.
pub async fn update_show_when_empty_indicator(configuration: &configuration::Configuration, tab_id: i64, screen_id: i64, new_value: bool, id: &str) -> Result<(), Error<UpdateShowWhenEmptyIndicatorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tab_id = tab_id;
    let p_screen_id = screen_id;
    let p_new_value = new_value;
    let p_id = id;

    let uri_str = format!("{}/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}/updateShowWhenEmptyIndicator/{newValue}", configuration.base_path, tabId=p_tab_id, screenId=p_screen_id, newValue=p_new_value, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateShowWhenEmptyIndicatorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

